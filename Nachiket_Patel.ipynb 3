{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Homework"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "internals": {
     "slide_helper": "subslide_end",
     "slide_type": "subslide"
    },
    "slide_helper": "slide_end",
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Problem 1\n",
    "Write a function to find the lines in a file that **contain** a word1 but **do not contain** word2."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 371,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "import re\n",
    "def findline(l,pattern,pattern1):\n",
    "    file = open(l,'r').readlines()\n",
    "    find = []\n",
    "    for i in file:\n",
    "        n = re.findall('^(?!.*{}).*{}.*$'.format(pattern1,pattern),i)\n",
    "        if n != []: find.append(n)\n",
    "            \n",
    "        \n",
    "    return find"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 372,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[['The threat sings outside another motorway!'],\n",
       " [\"Below a footnote hardens her men's deaf.\"],\n",
       " ['Another nastiest epic stumbles.'],\n",
       " ['Another global substance burdens a man.'],\n",
       " ['Another rabbit tags whatever hand opposite a complaining lens.'],\n",
       " ['Why does the microwave swear across another trying diner?'],\n",
       " ['Before the nose fails another shifting passport.'],\n",
       " ['The modified syndicate flies into another percent.']]"
      ]
     },
     "execution_count": 372,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "findline('reg_record.txt','not','is')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Problem 2\n",
    "Given the following dictionary:\n",
    "\n",
    "`\n",
    "roster = {'group1' :['Jack', 'Lisa'],\n",
    "          'group2' :['Mike', 'Mary'],\n",
    "     \t 'group3' :['John', 'Laura']} \n",
    "`\n",
    "- Get the keys and values of the dictionary.\n",
    "- Add a group4, item containing ‘David', ‘Susan’.\n",
    "- Convert all the names belong to group 2 to upper cases."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "group1 = ['Jack', 'Lisa']\n",
      "group2 = ['Mike', 'Mary']\n",
      "group3 = ['John', 'Laura']\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "['MIKE', 'MARY']"
      ]
     },
     "execution_count": 143,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "roster = {'group1' :['Jack', 'Lisa'],\n",
    "          'group2' :['Mike', 'Mary'],\n",
    "          'group3' :['John', 'Laura']} \n",
    "\n",
    "for k,v in roster.items():\n",
    "    print('{} = {}'.format(k,v))\n",
    "    \n",
    "    \n",
    "roster['group4'] = ['David','Susan']  \n",
    "\n",
    "[x.upper() for x in roster['group2']]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Problem 3\n",
    "Given an int count of a number of donuts, return a string of the form 'Number of donuts: **count**', where **count** is the number passed in. However, if the count is 10 or more, then use the word 'many' instead of the actual count. \n",
    "\n",
    "So **ex_3(5)** returns 'Number of donuts: 5' and **ex_3(23)** returns 'Number of donuts: many'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "def ex_3(n):\n",
    "    return (\"Number of donuts: {f}\".format(f = \"many\" if n >10 else n))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 373,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'Number of donuts: 3'"
      ]
     },
     "execution_count": 373,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "ex_3(3)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Problem 4\n",
    "- Revisit your application problem. Use the list comprehension this time:\n",
    "\n",
    "    Sum up the numbers divided by 3 or 5 from 1 to 999."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 165,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "233168"
      ]
     },
     "execution_count": 165,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sum([n for n in range(1,1000) if n%3==0 or n%5==0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- List comprehension with more complicated condition. Consider the list below, use list comprehension to assign 'a' to the numbers greater than 8; 'b' to the numbers less or equal to 8."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 376,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['b', 'b', 'b', 'b', 'b', 'b', 'b', 'b', 'a', 'a']"
      ]
     },
     "execution_count": 376,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Lst=range(1, 11)\n",
    "\n",
    "[\"b\" if n<=8 else \"a\" for n in Lst]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "- Again use list comprehension to assign 'a' to the numbers greater than 8; 'b' to the numbers less or equal to 8 and greater than 5; 'c' to everything else."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 183,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['c', 'c', 'c', 'c', 'c', 'b', 'b', 'b', 'a', 'a']"
      ]
     },
     "execution_count": 183,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "[\"b\" if n<=8 and n > 5 else \"a\" if n>8 else \"c\" for n in Lst]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "internals": {
     "slide_type": "subslide"
    },
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Problem 5\n",
    "\n",
    "Recall from yesterday's homework, *count_string('welcome to nyc(NYC) data science academy!', '')* returns 42, which is the length of the first argument. It is because we assign nothing to the second argument, so any character was counted. This time you need to rewrite the function **countString**, if the second argument is still nothing, the function should raise an **ValueError** with message: <p style=\"color: red\">The length of string_to_count should not be 0!</p>\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 189,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": [
    "# Your code here\n",
    "def countString(raw_string, string_to_count):\n",
    "    if string_to_count == '':\n",
    "        raise ValueError(\"The length of string_to_count should not be 0!\")\n",
    "    else:\n",
    "        return(raw_string.lower().count(string_to_count.lower()))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Here are some examples. Your function should return almost the same result."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 190,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "The length of string_to_count should not be 0!",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-190-e735653534b7>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mcountString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'hello, world!'\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m''\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0;31m# ValueError: The length should not be 0!\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-189-353d5521cee6>\u001b[0m in \u001b[0;36mcountString\u001b[0;34m(raw_string, string_to_count)\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;32mdef\u001b[0m \u001b[0mcountString\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mraw_string\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mstring_to_count\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m     \u001b[0;32mif\u001b[0m \u001b[0mstring_to_count\u001b[0m \u001b[0;34m==\u001b[0m \u001b[0;34m''\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m         \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"The length of string_to_count should not be 0!\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      5\u001b[0m     \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m         \u001b[0;32mreturn\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mraw_string\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlower\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcount\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstring_to_count\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mlower\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: The length of string_to_count should not be 0!"
     ]
    }
   ],
   "source": [
    "countString('hello, world!', '') \n",
    "# ValueError: The length should not be 0!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 191,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "2"
      ]
     },
     "execution_count": 191,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "countString('hello, world!', 'o') # 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 192,
   "metadata": {
    "collapsed": false,
    "internals": {
     "slide_helper": "subslide_end"
    },
    "slide_helper": "subslide_end",
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3"
      ]
     },
     "execution_count": 192,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "countString('hello, world!', 'l') # 3"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "internals": {
     "slide_type": "subslide"
    },
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Problem 6\n",
    "Write a function **countLetter** to count the number of frequencies of each letter occurs. In this case your function should only return the frequencies of letters that really occurs. Again, your function should be case **insensitive**.\n",
    "\n",
    "Hint: [chr(i) for i in range(97, 123)] is faster way to get the alphabet."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 198,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": [
    "from collections import Counter"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 217,
   "metadata": {
    "collapsed": true,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [],
   "source": [
    "\n",
    "def countLetter(raw_string):\n",
    "    return Counter(raw_string.lower())\n",
    "    \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "source": [
    "Here are some examples. Your function should return exactly the same result."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 218,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Counter()"
      ]
     },
     "execution_count": 218,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "countLetter('') # {}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 219,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Counter({'a': 2, 'b': 2, 'c': 2})"
      ]
     },
     "execution_count": 219,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "countLetter('ABCabc') # {'a': 2, 'b': 2, 'c': 2}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 402,
   "metadata": {
    "collapsed": false,
    "internals": {
     "slide_helper": "subslide_end"
    },
    "slide_helper": "subslide_end",
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "Counter({' ': 5,\n",
       "         'a': 4,\n",
       "         'c': 5,\n",
       "         'd': 2,\n",
       "         'e': 5,\n",
       "         'i': 1,\n",
       "         'l': 1,\n",
       "         'm': 2,\n",
       "         'n': 2,\n",
       "         'o': 2,\n",
       "         's': 1,\n",
       "         't': 2,\n",
       "         'w': 1,\n",
       "         'y': 2})"
      ]
     },
     "execution_count": 402,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "countLetter('welcome to NYC data science academy')\n",
    "# {'a': 4, 'c': 5, 'e': 5, 'd': 2, 'i': 1, 'm': 2, \\\n",
    "# 'l': 1, 'o': 2, 'n': 2, 's': 1, 't': 2, 'w': 1, 'y': 2}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "internals": {
     "slide_type": "subslide"
    },
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "### Problem 7\n",
    "The **bisection method** in mathematics is a root-finding method that repeatedly bisects an interval and then selects a subinterval in which a root must lie for further processing.\n",
    "\n",
    "Given a continuous function *f* and an interval $[a, b]$, which satisfies that the values of $f(a)$ and $f(b)$ are opposite, say $f(a)*f(b) < 0$(there is at least one zero crossing within the interval).\n",
    "\n",
    "- Calculate $c$, the midpoint of the interval, $c = 0.5 * (a + b)$.\n",
    "- Calculate the function value at the midpoint, $f(c)$.\n",
    "- If convergence is satisfactory (that is, $f(c)$ is sufficiently small), return $c$ and stop iterating."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<img src=\"http://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/Bisection_method.svg/640px-Bisection_method.svg.png\"/>"
      ],
      "text/plain": [
       "<IPython.core.display.Image object>"
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "from IPython.display import Image\n",
    "Image(url='http://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/Bisection_method.svg/640px-Bisection_method.svg.png')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "source": [
    "Write a function **binarySearchIter(fun, start, end,  eps)** to implement this idea, find the root of function *fun* in the interval $[start, end]$. Repeat the iteration until the absolute value of *fun(c)* is smaller than *eps*, and *eps* is a very small number, $10^{-10}$ for example. If $fun(start)*fun(end) \\ge 0$, raise an error with message <p style=\"color: red\">The sign of fun(start) and fun(end) should be opposite!</p>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 448,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [],
   "source": [
    "def binarySearchIter(fun, start, end,  eps=1e-10):\n",
    "    \n",
    "    if (fun(start) * fun(end)) >= 0:\n",
    "        raise ValueError(\"The sign of fun(start) and fun(end) should be opposite!\")\n",
    "       \n",
    "    c = (start + end)/2\n",
    "     \n",
    "    while abs(fun(c))>eps:\n",
    "        \n",
    "        \n",
    "        \n",
    "        if fun(start) * fun(c) < 0:\n",
    "            end = c\n",
    "        else: \n",
    "            start = c\n",
    "            \n",
    "            \n",
    "        c = (start + end)/2\n",
    "        \n",
    "    return c\n",
    "\n",
    "    \n",
    "    \n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "source": [
    "Here are three examples. Your function should return almost the same result."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 449,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-1.4142135623842478"
      ]
     },
     "execution_count": 449,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "def f(x):\n",
    "    return x ** 2 - 2\n",
    "binarySearchIter(f, -3, 0, eps = 1e-10) # -1.4142135623842478"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": false
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 389,
   "metadata": {
    "collapsed": false
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1e-10"
      ]
     },
     "execution_count": 389,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "eps"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 450,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.4142135623842478"
      ]
     },
     "execution_count": 450,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "binarySearchIter(f, 0, 3, eps = 1e-10) # 1.4142135623842478"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 451,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "3.000000000001819"
      ]
     },
     "execution_count": 451,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "binarySearchIter(lambda x: x ** 3 - 27, 0, 5, eps = 1e-10) # 3.000000000001819"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 452,
   "metadata": {
    "collapsed": false,
    "internals": {},
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "-3.000000000001819"
      ]
     },
     "execution_count": 452,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "binarySearchIter(lambda x: x ** 3 + 27, -5, 0, eps = 1e-10) # -3.000000000001819"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 419,
   "metadata": {
    "collapsed": false,
    "internals": {
     "slide_helper": "subslide_end"
    },
    "slide_helper": "subslide_end",
    "slideshow": {
     "slide_type": "-"
    }
   },
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "The sign of fun(start) and fun(end) should be opposite!",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-419-51c2127b1e86>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mbinarySearchIter\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;32mlambda\u001b[0m \u001b[0mx\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mx\u001b[0m \u001b[0;34m**\u001b[0m \u001b[0;36m3\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;36m27\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;36m5\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0meps\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;36m1e-10\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0;31m# ValueError: The sign of fun(start) and fun(end) should be opposite!\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m<ipython-input-416-cccfe13be019>\u001b[0m in \u001b[0;36mbinarySearchIter\u001b[0;34m(fun, start, end, eps)\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m      \u001b[0;32mif\u001b[0m \u001b[0;34m(\u001b[0m\u001b[0mfun\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mstart\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m*\u001b[0m \u001b[0mfun\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mend\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m>=\u001b[0m \u001b[0;36m0\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m         \u001b[0;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"The sign of fun(start) and fun(end) should be opposite!\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      5\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m      \u001b[0;32mwhile\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mValueError\u001b[0m: The sign of fun(start) and fun(end) should be opposite!"
     ]
    }
   ],
   "source": [
    "binarySearchIter(lambda x: x ** 3 + 27, 0, 5, eps = 1e-10) \n",
    "# ValueError: The sign of fun(start) and fun(end) should be opposite!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "collapsed": true
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
